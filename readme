算法描述

尝试使用C/C++ 使用描述（实现）一些算法，希望在此交流互相学习。
若你发现其中存在问题，可以随时联系本人。
e-mail：huangjunkun@gmail.com

欢迎交流，谢谢！

####### 9.
####### 8.
####### 9.
/**
** 源文件： knapsack _test.cpp
** 功能说明：
** 测试程序，背包问题与记忆功能。算法详细介绍详见《算法分析与设计》8.4背包问题与记忆功能。
** 作者：junkun huang  e-mail：huangjunkun@gmail.com
** 创建日期：2008-11 /
*/

####### 8.
/**
** 源文件： horner_rule.cpp
** 功能说明：
** 测试程序，霍纳法则用于计算多项式值的一种古老的算法，但却十分优雅和高效。
** 霍纳法则还有一些有用的副产品，例如有多项式P(x)，在计算P(a)的值过程产生的中间数字，
	可组织作为P(X)除以X-a商与余数。详见《算法分析与设计》6.5.1霍纳法则。
** 关于霍纳法则，详见http://baike.baidu.com/view/3060869.htm
** 作者：junkun huang  e-mail：huangjunkun@gmail.com
** 创建日期：2008-11 /
*/

####### 7.
/**
** 源文件： binomial_coefficient.cpp
** 功能说明：
** 测试程序，计算二项式系数，一个动态规划解法应用的典型例子，简单易理解。
** 作者：junkun huang  e-mail：huangjunkun@gmail.com
** 创建日期：2008-11 /
*/

####### 6.
/**
** 源文件： greatest_common_divisor.cpp
** 功能说明：
** 测试程序，计算两个数的最小公约数，不同解法：
	a. 欧几里得算法 gcd1.
	b. 计算gcd(m, n)的连续整数检测算法gcd2.
	c. 中学里的计算方法gcd3, 相对最复杂的办法,但是有效的.
		1 找到m的所有质数prime1；
		2 找到n的所有质数prime2；
		3 从prime1和prime2中找出所有的公因数com_prime。
		注意：如果p是其中一个公因数，而且在prime1和prime2中分别出现Pm，Pn次
		那么应该将p重复min{Pm, Pn}次；
		4 将com_prime的所有质因数相乘，结果即m, n最大公约数。
		（gcd3解法O_o 够折腾的求解过程吧。）

** 作者：junkun huang  e-mail：huangjunkun@gmail.com
** 创建日期：2008-11 /
*/

####### 5.
/**
** 源文件： convex_hull.h, convex_hull.cpp
** 功能：凸包问题的解决方案, 蛮力法与分治法.
** 蛮力法使用到几何知识:
 P1，P2{(x1, y1), (x2, y2)} => ax + by = c
 => {a = y2-y1, b = x1 - x2, c = x1y2 - y1x2}
 使用公式ax + by = c可判断点P3(x3, y3)落在{(x1, y1), (x2, y2)}哪边.
蛮力解法步骤：
1. 循环遍历所有的点，找出所有像P1，P2的点，需满足条件：
 其他所有的点均分布在直线P1P2同一边，借助以上几何知识。
2. 找出了所有这样的点，那么就完成凸包问题。

蛮力解决方案时间复杂度O(n^3).

** 分治法使用到几何知识:
 {(x1, y1), (x2, y2), (x3, y3)} P1, P2, P3.面积S(P1P2P3)为以下行列式绝对值的一半，
 |x1 y1 1|
 |x2 y2 1| = x1y2 + x3y1 + x2y3 - x3y2 - x2y1 - x1y3
 |x3 y3 1|
 P3位于直线P1P2的左侧时，该表达式为正值。
 P3位于直线P1P2的右侧时，该表达式为负值。
 该绝对值越大，即P3就与直线P1P2距离越大。
分治解法步骤：
1. 按照X轴（或Y轴）排序点集合S0，得到最小大值P1，Pn，并划分上包，下包不同点集合。
2. 以上包为例，根据以上几何知识，找出上包顶点Pmax即距离P1Pn最远的点，找不到即结束。
3. 继续以P1Pmax和PmaxPn构造上包，递归下去直至找不到上包顶点。得到点集合S1.
4. 下包操作同。得到点集合S2.
5. 合并集合S1, S2, 得到S3即凸包结果.

分治法解决方案时间复杂度O(n^2).
btw 详细的算法可以参见<算法分析与设计> 3.蛮力法3.3.2凸包问题 & 4.分治法4.6.2凸包问题.
** 算法实现详见以上源文件代码.
** 凸包问题描述:
	定理:任意包含n>2个点（不共线）的集合S的凸包是以S中的某些点为顶点的凸多边形。
	凸包问题是为一个n个点的集合构造凸包的问题。
	极点：对于任何一集合中的点为端点的线段来说，它们不是这种线段的中点。
** 作者：junkun huang  e-mail：huangjunkun@gmail.com
** 日期：2009-09-20 /
*/

####### 4.
/**
** 源文件： min_spanning_tree.cpp
** 功能说明：
** 测试程序，最小生成树问题CMST解决方案Prim算法与Kruskal算法。
** 作者：junkun huang  e-mail：huangjunkun@gmail.com
** 创建日期：2008-11 /
*/

####### 3.
/**
** 源文件： nearest_neighbor_search.cpp
** 功能说明：
** 测试程序，最近点对问题解决方案，蛮力法与分治法。详见以下代码。
** 作者：junkun huang  e-mail：huangjunkun@gmail.com
** 创建日期：2008-11 /
*/

####### 2.
/**
** 源文件： shortest_path.cpp
** 功能说明：
** 测试程序，最短路径问题解决方案，Floyd算法与Dijkstra算法。详见以下代码。
** 作者：junkun huang  e-mail：huangjunkun@gmail.com
** 创建日期：2008-11 /
*/

####### 1.
/**
** 源文件： random_list_node.h, random_list_node_test.cpp
** 功能：拷贝“随机链表”，即节点带有一个指针可能指向链表随机另一个节点的链表。
** 一般的简单蛮力算法，可完成该功能，但时间复杂度为 O(n*m)。而以下算法较高效，相比时间复杂度为O(m).
** 具体操作，需要遍历源链表三遍。包括拷贝链表+复制随机指针+回复源链表NEXT指针。
** 作者：junkun huang  e-mail：huangjunkun@gmail.com
** 日期：2011-06-10 /
*/

####### 0.
/**
** 源文件： hanoi_tower_test.cpp
** 功能说明：
** 测试程序，汉若塔的计算（搬运次数）与演示搬运过程。
** 作者：junkun huang  e-mail：huangjunkun@gmail.com
** 创建日期：2008-11 /
*/